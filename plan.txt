--------------------------------------------------[TODO]
>TODO: 加入 .resources 目录中的 Utilities placeholder 省略号等。
>TODO: include (from site.js)
>TODO: 加入 slide scroll 动画后全项目搜索 fade 关键字，在相应位置补齐对应的说明。
>TODO: $ 添加白名单。
&& !(/^(?:object|embed)$/i).test(el.tagName)
>TODO: Overlay 升级，支持移动设备浏览器的特殊视口。
>TODO: 表单序列化。
>TODO: History
>TODO: SWFObject

>考虑“模块”和“应用”机制的实用性。这个机制可以很方便的隔离 JS 代码，但实际项目中，很多隔离开的模块却公用一些 DOM 对象。
“模块”和“应用”是面对复杂的项目时应该使用的策略。在 OurJS 中对它们的定义如下：
“模块”即可分离的业务逻辑，将整个项目中相对独立的部分编写为一个模块以实现解耦。
各模块之间相互不依赖，也不能通信。这种隔离的设计有利于各模块的独立开发和测试，同时也可以减少项目变更时某一部分代码的修改对其他部分造成的影响。
“应用”是连接各“模块”的桥梁。“模块”只能与“应用”通信，反之亦然。可以同时存在多个“应用”，但需要注意在“应用”的代码中仅应处理各“模块”的信息，而不应该有其他业务逻辑。
在需要扩展应用的功能时，应为其添加新的“模块”，并添加新的“应用”函数来处理新的逻辑，以避免新增的逻辑影响以前的代码。
灵活使用“模块-应用”机制，可以游刃有余的应对频繁改动的项目。

>UI 组件
IE9- delete -> removeAttriburte

是否还有必要为了避免 IE6 的内存泄漏而使用比较麻烦的方法编写库和组件？
泄漏主要是由于 DOM 对象的事件监听器的作用域链有对 DOM 对象的引用。
而且在 XP sp3 版本的 IE6，只要不将这些 DOM 对象从文档树中移除，很难察觉是否还存在内存泄漏问题。
目前的方式是为元素设定 uid 作为该元素的 key，并在必要时建立“影子对象”，在其中保存扩展的内容（包括监听器）。
“影子对象”与 DOM 对象是通过 uid 关联的，要保证在 DOM 对象被丢弃的时候清理“影子对象”，就要封装所有相关的方法(1)。
  - 事实上目前主流的库也没有特地处理这种情况，因为不做二者的同步问题也不大，在离开本页后“影子对象”可以被正常回收。
但如果不使用“影子对象”，将数据直接保存在 DOM 对象上，即可避免处理这种同步的问题，而且可以简化编码，使逻辑更清晰。
  - 目前 IE6 在国内的份额是 25% 左右，非企业应用的情况下内存泄漏造成的影响并不严重。
若在不使用“影子对象”的情况下避免 IE6 的内存泄漏，可以使用上述(1)中提到的方式，封装能够导致 DOM 对象被丢弃的方法（remove、replace、innerHTML、outerHTML、innerText、outerText、deleteRow 等）来解决问题。

目前构造器形式的 UI 组件均至少依赖一个已经存在于文档树中的元素，且几乎不会出现将一个元素作为多个 UI 组件的“源”使用的情况。
因此考虑将 UI 组件逐步替换为以 widget-type 元素直接植入 HTML 代码的形式，以使 UI 组件的代码更紧凑，更易用。
需要考虑的问题有以下几点：
  * 针对 html 的解析及后续的修改、克隆操作，目前要实现能与浏览器的行为近似的功能比较困难(!)，因此对一致性略有影响。
    也就是说这个修改是以牺牲“一致性”的代价来换取“易用性”的。
  * 提供 pool 存储 UI 组件的数据，并与对应元素关联。<- ???
  * 初始化时需要多个元素的 UI 组件，通过约定这些元素的 class 来标识。
  * 原 Configurable 特性以自定义属性的方式提供，不使用普通属性是因为普通属性应该是可修改并能实时生效的，但目前这一特性实现成本太高(!)。
    而自定义属性恰好在语义上有“配置参数”的含义。<- xxx
  * Observable 特性以 DOM 事件的方式提供。
    需重写事件处理部分，禁止所有非标准 DOM 事件在 DOM 树中传播。

/*
TODO: [LOW] 避免多次 fix 同一个同类型的 DOM 事件对象。
DONE: 以上取消，因为 IE6 IE7 IE8 无法避免，在这些浏览器中，每个监听器传入的事件对象都是不同的。
      其他浏览器中虽然可以避免，但为了保持一致，并简化逻辑、提高效率（事实上同一事件被不同节点监听的情况相对来说是很罕见的），也不做处理。
      在 jQuery 1.7.1 中也未做此处理。

TODO: [LOW] fadeIn/fadeOut 逻辑合并；animation.stop 方法缺少恢复初始状态的功能（考虑到通过事件添加的非线性变换，此功能难以实现，暂建议在 playstart 事件发生时手动处理）。
DONE: 已实现。

TODO: 绑定事件时增加 :once 特性。
DONE: 以上取消，它使 API 变复杂。可以通过 label 来手动实现 once 或者 twice 之类的功能。

TODO: components 的 options 参数，应区分为“可改写”和“不可改写”两种，“不可改写”的不要附加在实例上。
DONE: 以上取消，太复杂。
      现在的方式是将选项保存到实例的 options 属性内。既然叫做“选项”，就应该让它们都可以改写，并且能在特定的时机生效。

TODO: 事件部分 fire 参数由 type 改为 name。
DONE: 不会实施这个修改，这会把事情变复杂。如果需要触发特定的一些监听器，应该为它们单独指定 type。

TODO: Animation 继续参考 CSS3 Transition，增加 delay 参数，并对外暴露 timingFunction。
      [low] 添加反向动画支持。
DONE: Animation 已使用新的思路设计，上述内容全部可以实现。

TODO: 以下命令不符合预期，应考虑加入 deffered 类型。
      或者加入在调用 stopAnimation 也会触发的 onComplete 回调，这样就可以在 onComplete 里加入状态处理的代码，而在 onFinish 中加入其他（如动画队列）代码。
      bodyMask.show().hide().show().hide().show().hide().show();
DONE: 使用新的 Animation 即可解决上述问题。
*/

--------------------------------------------------[注释风格]
/**
 * @fileOverview <文件描述>
 * @author <作者信息>
 * @version <版本号 - 日期>
 */

(function() {
<本模块的公用变量>

//==================================================[<代码块标题>]
  /*
   * <代码块详细描述>
   */

<本代码块的公用变量>

//--------------------------------------------------[<方法/属性说明>]
  /*
   * <不想添加到文档的附加说明>
   */
  /**
   * <短描述>
   * @name <名称>
   * @memberOf <隶属对象>
   * @constructor @function @namespace @type <值类型>
   * @private
   * @param {<类型1|类型2>} <参数名> <参数描述>
   * @param {<类型1|类型2>} [<参数名>] <参数描述>
   * @returns {<类型1|类型2>} <返回值描述>
   * @fires <事件名>
   *   <事件描述>
   * @fires <事件名>
   *   <事件描述>
   * @description
   *   <长描述(可包含 HTML 代码)>
   * @example
   *   <示例代码>
   * @example
   *   <示例代码>
   * @requires
   * @since
   * @deprecated
   * @see <参考链接>
   * @see <参考链接>
   */
<本方法的私有变量>

<本方法的主体代码>

...

})();

--------------------------------------------------[NOTE]
#Global
#Object
#Function
#Array
#String
#Boolean
#Number
#Math
#Date
#RegExp
#Error
#JSON

[modularization]
Application 即页面应用。
Modules 即可分离的业务逻辑，各自独立，不会互相依赖，也不能互相访问。它们使用消息机制与 Application 通信。
只有 Application 可以与 Modules 通信。
只有 Modules 可以与 Application 通信。

[inherit]
extends 只能逐级继承，应使用原型链。
implement 可以并行实现多个“接口”（实际也应用各构造器），应使用原型拷贝。

[API 风格]
可选参数不再强制为一个 options，必要时应归类以保持同类方法的参数含义相同。

简单、自然、完整、一致、易扩展。

API必须要提供充分的功能，以供调用者完成自己的任务。
API应该是最精简的，不要为调用者带来多余的不便。
如果没有理解API的使用环境的话，那也就不能去设计它。
通用性的API应当是与具体使用场景无关的，而特定用途的API则要充分考虑使用策略。
API应该从调用者的角度来进行设计。
好的API绝不推卸责任，把自己该做的事情留给别人。
在实现API之前，就应该把API文档化。
好的API应当符合工效学。

#http://www.slideshare.net/Dmitry.Baranovskiy/your-javascript-library
Everything should be made as simple as possible, but no simpler.
