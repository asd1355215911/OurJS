

>2012-12-07
事件列表外的类型不再使用触发器或分发器。

>2012-12-04
整理文档。

>2012-11-19
优化事件模型[100%]
修复 input change 事件的兼容性问题，修改“事件名称”和“事件标签”的描述信息。

>2012-11-16
getting_start -> guide

>2012-11-15
更新事件模型 [50%]。
控件 -> Widget

>2012-11-14
更新事件模型，修改一些名称，修改事件传播的方式，归纳为两种处理模式。

>2012-11-10
Form.setValidationRules -> widget-validator
DatePicker 的 valuechange 事件名改为 change。

>2012-11-09
APIReference 相关文件和代码修改。
Slideshow 幻灯片小于两张时静态化。
修改所有代码中的 timer。

>2012-11-08
widget-slideshow

>2012-11-07
Widget parser 找不到时给出警告信息。
为 DatePicker 增加 valuechange 事件。

>2012-11-05
源码中用到 $ 的地方改为其原名 document.$。
未使用 var $ = document.$，性能开销不大，但可读性更好（更明确）。

>2012-11-01
将 JSONPRequest 合并到 Request 中。
去掉 requestParser 和 responseParser，它们应写在应用代码中，基础 API 不提供此类过滤功能。
事件名改为 start、abort、timeout、complete 和 finish。

>2012-10-31
+JSONPRequest

>2012-10-30
-Switcher
没有合适的地方安排它，并且它提供的功能粒度稍粗。
-Configurable
目前无存在必要，计划以后将其修改为全兼容的 getter/setter 特性。
-Component
现在的 Widget 代替了其主要功能。
Animation 和 Request 不再叫做“组件”。
-getNamespace
本方法极少用到。
-execute
execute 是 对 jQuery 兼容的临时性解决方案，目前功能已经比较完善，可以弃用。
需要与 jQuery 并存时，仍需要 var $ = document.$; 保持兼容，独立代码直接使用 $ 即可。
-declareModule
-runApplication
由于“模块”和“应用”机制的实用性欠佳，因此将删除它们。
这个机制可以很方便的隔离 JS 代码，但实际项目中，很多隔离开的模块却公用一些 DOM 对象。
同时这个机制对开发人员的要求也比较高。一方面在设计“模块”时需要具备一定的抽象能力，另一方面还要禁止在“应用”中出现业务逻辑。
删除后，业务逻辑复杂的项目要尽量利用 DOM 元素和 DOM 事件来聚合同类功能。
#“模块”和“应用”是面对复杂的项目时应该使用的策略。在 OurJS 中对它们的定义如下：
#“模块”即可分离的业务逻辑，将整个项目中相对独立的部分编写为一个模块以实现解耦。
#各模块之间相互不依赖，也不能通信。这种隔离的设计有利于各模块的独立开发和测试，同时也可以减少项目变更时某一部分代码的修改对其他部分造成的影响。
#“应用”是连接各“模块”的桥梁。“模块”只能与“应用”通信，反之亦然。可以同时存在多个“应用”，但需要注意在“应用”的代码中仅应处理各“模块”的信息，而不应该有其他业务逻辑。
#在需要扩展应用的功能时，应为其添加新的“模块”，并添加新的“应用”函数来处理新的逻辑，以避免新增的逻辑影响以前的代码。
#灵活使用“模块-应用”机制，可以游刃有余的应对频繁改动的项目。

>2012-10-27
更改目录结构。

>2012-10-26
修复 dispatchEvent 在监听器内添加或删除目标元素同类型的监听器时会影响本次派发过程的问题。

>2012-10-25
widget-datepicker

>2012-10-24
widget-calendar
Widget 元素中原本不存在的元素（即初始化或调用某个方法后动态创建的元素）统一以 key-value 的形式保存到本元素的 elements 属性中。

>2012-10-23
修改 $ 函数的 wrappers。

>2012-10-21
widget-paginator 支持两种模式

>2012-10-20
+Widget.register
不再使用 INS[widget=xxx] 来表示控件，改为 class=widget-xxx 指定。
使文档注释支持 @attribute 标签。

>2012-10-18
更改文件夹结构，将 demos 合并。

>2012-10-17
使用 CSS Expression 修复 IE6 下控件元素的属性选择符，并自动处理固定定位。
IE6 position: fixed 可以和其他浏览器一样在样式表中使用了。
console.js 的历史纪录功能不再重复记录相同的输入。
W-XXX -> INS[widget=XXX]

>2012-10-16
W-DIALOG
Widget 使用自定义标签还是生僻标签？
[自定义标签]
优点：
  自描述；便于定义 CSS。
缺点：
  IE6 IE7 IE8 需要 hack，并在对某元素使用 innerHTML 创建时需要该元素在文档树内才能被正确解析，另外 tagName 或 nodeName 与开始标签书写时的大小写相同（其他浏览器则均为大写字母），若使用 namespace 还有被从冒号处截断的问题。
[生僻标签]
优点：
  正常标签可以任意方式使用。
缺点：
  IE6 中定义 CSS 不便（需使用表达式修复）。

>2012-10-15
W-OVERLAY

>2012-10-14
UIComponent -> Widget
W-TABPANEL

>2012-10-12
+String.prototype.capitalize
+String.prototype.camelize
+String.prototype.underscored
+String.prototype.dasherize

>2012-10-11
升级 Highcharts adapter，使其支持 Highstock 最新版。
tabPanel -> widget-tabpanel

>2012-10-10
addons -> utilities

>2012-10-09
修复 Highcharts 适配器事件处理的 bug。

>2012-10-08
+widget.js

>2012-09-28
完善 setValidationRules。

>2012-09-27
修复 navigator.warn 的一处 bug。

>2012-09-26
调整代码注释。

>2012-09-25
Element.prototype.compareDocumentPosition 更改为补缺方法。

>2012-09-24
Validator -> Form.setValidationRules

>2012-09-21
Animation 和 Request 修改。
Request 版本 20120208 的实现是每个 request 仅创建一个 XHR 对象，多次发送请求则重复使用。
考虑到同一 request 的不同请求调用 setRequestHeader 时传入的值可能不同，修改为不重用 XHR 对象，以免出现预料外的问题。

>2012-09-20
+Array.prototype.remove

>2012-09-18
修改 getFieldValue 的返回值模式。

>2012-09-17
IE6 打开图片缓存挪到 browser.js 中。

>2012-09-10
更新 Sizzle 版本。
更新 Validator。

>2012-08-30
+Element.prototype.cancelAnimation

>2012-08-28
合并 fadeIn 和 fadeOut 为 fade。
演示文档。

>2012-08-27
log -> logger

>2012-08-24
简化 localStorage 的实现。

>2012-08-23
修改文档，明确“组件”一词的含义。
为 IE6 IE7 的 localStorage 提供可配置的存储路径。

>2012-08-22
修改 getStyle 方法。

>2012-08-20
将 Component 构造器提供的处理选项和事件的特性拆分为 Configurable 和 Observable，它们可以通过 enable 方法在任何对象上启用。
Component 构造器不再自动处理 options 参数。
增加 Switcher.prototype.spliceItems 方法。
options -> config
setOptions -> setConfig

>2012-08-16
+clone

>2012-08-15
+swap
+insertAdjacentText/Element

>2012-08-14
prependChild/putBefore/putAfter -> insertTo

>2012-08-13
Object.append -> Object.mixin
-Element.prototype.append
Element.prototype.prepend -> Element.prototype.prependChild

>2012-08-10
dispatchEvent 不再返回 event 对象；fire 方法不再返回调用本方法的对象，而是返回 event 对象。

>2012-08-09
+document.loadScript
提供 Highchart 的适配器。

>2012-08-07
get/setStyle 方法不再接受 Hyphenate 格式的参数。
修复由于 IE9- 的 replace 方法被嵌套调用导致的正则表达式对象的 lastIndex 属性不归零的问题。
将正则表达式对象的常量命名修改为变量命名 xxxPattern。

>2012-08-06
+document.addStyleRules
修复 dispatchEvent 传播事件时的 bug。
使 window/document 上的 mouseenter/leave 事件监听正常。

>2012-07-30
开放文档。

>2012-07-27
Mask -> Overlay

>2012-07-23
+Validator
getPrevious -> getPreviousSibling
getNext -> getNextSibling
getFirst -> getFirstChild
getLast -> getLastChild

>2012-07-19
Component 修改，使其像最初版本一样，能自动处理选项。
修改后将第二、三个参数设为可选。创建内置组件时均省略了这两个选项，以使代码更清晰。

>2012-07-18
入门指南。

>2012-07-16
简介。

>2012-07-13
更改目录结构。

>2012-07-12
编辑文档。
  - 明确各组件的各方法何时调用有效，以明确对应的事件在什么情况下会触发。
  - 明确各 Function 类型的参数的 this 指向。

>2012-07-11
Pagination -> Paginator

>2012-07-10
确保 setOptions 可以在实例创建后生效。

>2012-07-09
Slideshow
明确 undefined & null 的使用场景。

>2012-07-07
Fx.* -> Animation.createBasicRenderer/createStyleRenderer。
fadeIn/fadeOut 合并。

>2012-07-06
修复 on('play', function() {this.pause/stop();}) 无效的问题。
取消队列，加入列表。
  - 目前的动画队列并不实用，其功能也不如 Animation 上提供的 clips 强大，因此决定去除此特性，因此也消除了对链式写法的“同步插入队列但异步执行”的歧义。
  - 简单动画本意为指定一个终点，做补间动画。希望在动画结束后做的事情，放在 onFinish 回调中更容易理解。
  - 增加“本元素播放中的动画列表”特性，这个特性可以让同一个元素上播放的同类动画合并（或抵消），在多种有动画效果的组件编写中可以简化开发。
去掉 delay 参数，没有队列更加没有意义。
去掉 highlight 的 times 参数。
删除 Fx.highlight ，去掉 times 后完全可以由 morph 代替。
//--------------------------------------------------[Fx.highlight]
  /**
   * 高亮效果渲染器。
   * @name Fx.highlight
   * @function
   * @param {Element} $element 要实施渐隐效果的元素。
   * @param {string} [property] 高亮样式名，默认为 'backgroundColor'。
   * @param {string} [color] 高亮颜色，默认为 'yellow'。
   * @param {number} [times] 高亮次数，默认为 1。
   * @returns {Function} 生成的渲染器。
   */
  Fx.highlight = function($element, property, color, times) {
    property = property || 'backgroundColor';
    color = color || 'yellow';
    times = times || 1;
    // 内部分多次动画换算后，使用此控速函数。
    var map;
    var nativeSection = 1 / times;
    var renderer = function(x) {
      if (map === undefined) {
        var style = {};
        style[property] = color;
        map = getStylesMap($element, style);
      }
      var beforeValue = map.before[property];
      var afterValue = map.after[property];
      if (x === 0 || x === 1) {
        $element.setStyle(property, convertToRGBValue(beforeValue));
      } else {
        var nativeX = (x % nativeSection) / nativeSection;
        var nativeY = renderer.timingFunction(nativeX);
        $element.setStyle(property, convertToRGBValue([
          Math.floor(afterValue[0] + (beforeValue[0] - afterValue[0]) * nativeY),
          Math.floor(afterValue[1] + (beforeValue[1] - afterValue[1]) * nativeY),
          Math.floor(afterValue[2] + (beforeValue[2] - afterValue[2]) * nativeY)
        ]));
      }
    };
    renderer.type = 'highlight';
    return renderer;
  };

//--------------------------------------------------[队列]
  // 简单动画的队列，为队列中的 Animation 对象增加类似 renderer 的 type 属性，以供动画合并时使用。
  var queuePool = {};

  // 播放指定的队列。
  var playQueue = function(queue) {
    queue.getFirst()
        .on('playfinish.native', function() {
          queue.shift();
          if (queue.length) {
            setTimeout(function() {
              playQueue(queue);
            }, 0);
          } else {
            delete queuePool[queue.id];
          }
        })
        .play();
  };

  // 在指定的队列中添加一个动画。
  var appendToQueue = function(uid, animation) {
    var queue = queuePool[uid];
    if (queue) {
      queue.push(animation);
    } else {
      queue = queuePool[uid] = [animation];
      queue.id = uid;
      playQueue(queue);
    }
  };

>2012-07-05
Fx.base -> Fx.custom
合并动画队列中的连续 fadeIn/fadeOut。

>2012-07-03
修复 playstart/reversestart 在极特殊情况下多次调用的 bug，如 animation.play().pause().play() 或调用 play 方法时恰好与引擎本次运转的时间完全一致的情况。
修改 stop 方法的行为，现在调用 stop 方法时，各剪辑的 renderer 函数将被以参数 (0, 0) 调用一次，以恢复动画的初始状态。
合并动画队列中的连续高亮。

>2012-07-01
修改 Request 的事件名称。

>2012-06-28
表单增强-日期选择器。

>2012-06-27
取消 2012-06-15 针对组件事件可以取消默认行为的修改。
1. 可取消默认行为的组件事件增加了组件编写和使用的复杂度，并且应用场景极少。
2. DOM 事件由用户直接触发，触发时应用逻辑无法介入，因此阻止其默认行为的功能只能在事件监听器中进行；
   组件事件由用户触发的 DOM 事件触发，此时应用逻辑可以，并且已经介入，没有在组件事件发生后进一步阻止其默认行为的必要。
对于同步事件，在状态处理完毕之后触发，相较之前的“未取消默认行为则在回调函数中处理状态”的方式更科学（可以在事件监听器中获取组件的实例更新后的状态）。
对于异步事件，仍与以前的方式一致，明确各关联事件触发的时序。

>2012-06-26
去掉 Dialog 的浏览器禁用动画的判断，将相关注释写入代码，启用动画与否由用户在应用中控制。
Date.from

>2012-06-24
Date.prototype.format

>2012-06-22
压缩事件管理的数据模型。

>2012-06-21
修改 window/document/Element.prototype.on/off 的参数，取消 filter，参考 MooTools 的语法，使用 :relay(selector) 实现代理。
统一 on/off 的参数 name，省略标签时不再删除该类的所有事件监听器。

>2012-06-18
修改 new Fx.Morph 为 Fx.morph。
修改 Element.prototype.highlight/Fx.highlight 的参数，可选参数不再强制为一个 options，必要时应归类以保持同类方法的参数含义相同。

>2012-06-17
animation.addClip 修改。

>2012-06-16
修复 Animation.prototype.pause 丢失 timePoint 的 bug。
为组件事件添加事件源。

>2012-06-15
修改 Element.prototype.morph/highlight/fadeIn/fadeOut 方法：
  - 队列由 clip 修改为 animation。
  - 统一选项。
  - 将回调函数由 callback 改为 onStart 和 onFinish。
Component.prototype.fire 添加第三个参数，以支持 event.preventDefault 方法。建议在用户调用组件的各方法时触发的事件中使用。
取消 Fx.Fade，因为这个效果不仅是“线性变换”，还涉及到在“首末帧”修改 display 属性的值，这将导致 Animation 的 beforestart/afterstart 等事件的处理变得复杂。
//--------------------------------------------------[Fx.Fade]
  /**
   * 渐隐效果。
   * @name Fx.Fade
   * @constructor
   * @param {Element} $element 要实施渐隐效果的元素。
   * @param {string} mode 渐隐模式，in 为渐入，out 为渐出。
   * @param {number} delay 延时。
   * @param {number} duration 播放时间。
   * @param {string} timingFunction 控速函数名称或表达式。
   */
  Fx.Fade = function($element, mode, delay, duration, timingFunction) {
    var isFadeInMode = mode === 'in';
    var originalOpacity;
    this.handler = function(x, y) {
      if (originalOpacity === undefined) {
        originalOpacity = $element.getStyle('opacity');
      }
      var isPlayMethod = this.status === PLAYING;
      var styles = {
        // 正常状态。
        normal: {'display': 'block', 'opacity': originalOpacity},
        // 全透明状态。
        fullTransparency: {'display': 'block', 'opacity': 0},
        // 隐藏状态。
        noDisplay: {'display': 'none', 'opacity': originalOpacity}
      };
      switch (x) {
        case 0:
          $element.setStyles(styles[isFadeInMode ? (isPlayMethod ? 'fullTransparency' : 'noDisplay') : 'normal']);
          break;
        case 1:
          $element.setStyles(styles[isFadeInMode ? 'normal' : (isPlayMethod ? 'noDisplay' : 'fullTransparency')]);
          break;
        default:
          $element.setStyle('opacity', (originalOpacity * (isFadeInMode ? y : 1 - y)).toFixed(2));
          break;
      }
    };
    this.delay = delay;
    this.duration = duration;
    this.timingFunction = getTimingFunction(timingFunction);
  };

>2012-06-14
Animation 的 playstart/reversestart 事件改为 step 之前。
修改 Dialog 逻辑。
取消 0610 的修改，以使 append/prepend 能够返回本元素。
cookie.set -> cookie.setItem
cookie.get -> cookie.getItem
cookie.remove -> cookie.removeItem
element.getFirstChild -> element.getFirst
element.getLastChild -> element.getLast
更改注释文档，以使同一类 API 的说明和参数的风格尽量保持一致。

>2012-06-12
-components
取消 Animation 的可选参数。

>2012-06-10
-element.append
element.prepend -> element.prependChild

>2012-05-29
编辑“概述”文档。
修改 API 文档细节。

>2012-05-24
-navigator.isIE

>2012-05-22
添加 input 事件支持。

>2012-04-27
Number.prototype.toRegular -> Number.prototype.padZero

>2012-04-18
首末帧同步处理，中间帧挂载到引擎。
bodyMask.show().hide().show().hide().show().hide().show().show().hide().hide().show().hide();
使用升级后的 Animation 测试通过。

>2012-04-16
取消简化版动画的多队列支持。

>2012-04-09
Animation 升级

>2012-04-07
Request 更新

>2012-04-05
execute(codeBlock[, waitingForDomReady])

>2012-04-04
TabPanel 更新
Calendar

>2012-04-02
Component
Switcher 更新。
TabPanel: change

>2012-03-31
-Object.append
-Object.update
Object.merge -> Object.append

>2012-03-30
Object.merge

增加 Component 类，提供与 Element/document/window 相同的操作事件的方法 on/off/fire。
这样处理之后，创建组件的实例时“选项”和“事件监听”就可以在代码中更明显的区分开。
修改前：
1. 组件的事件处理仅提供一个回调函数，必须处理多种情况时，只能使用新的函数来包装原有的函数。
2. 创建组件时的语法将选项和事件监听器混在一起，最初的考虑是它们都是可选的。如下：
var componentA = new ComponentA(param1, param2, {
  option1: value1,
  option2: value2,
  onEventName1: function(e) {
    // ...
  },
  onEventName2: function(e) {
    // ...
  }
});
修改后：
1. 组件在每个事件上可以处理多个监听器了。
2. 因为组件是被设计为可以重用的，现在使用以下语法，表达得更清晰：
var componentA = new ComponentA(param1, param2, {
  option1: value1,
  option2: value2
}
    .on('eventName1', function(e) {
      // ...
    })
    .on('eventName2', function(e) {
      // ...
    });
3. 修改后，创建组件的实例时由于尚未监听任何事件，因此不要在组件的初始化函数中设计有触发事件的行为，事件的触发点应该为调用某方法后。
4. 对于非组件，有回调的时候仍使用参数形式，传入对应的 onEventType 来完成，因为非组件是一次性运行的，不能重用，这样处理便于理解。

>2012-03-28
components.TabPanel 修改，将“容器”的必选参数改为可选参数。在通过清晰的约定可以减少必选参数时，组件更容易使用。
examples +

>2012-03-26
components.TabPanel

>2012-03-25
getAnimationQueue

>2012-03-23
生成细节页。

>2012-03-22
生成索引页。
修改 IE6 Mask 遮盖 SELECT 的方式。
  当页面 HTML 元素设置了非正常背景图片时（找不到图片或 about:blank），IFRAME 无法遮盖 SELECT 元素（滚动窗口 SELECT 即再次在最前端显示），但若此时页面内有 fixed 定位的元素即无此问题。
  解决方案：将 IE6 的 BODY 遮盖层也使用 fixed 定位。

>2012-03-21
将代码存放在 github。

>2012-03-20
将 JS 文件内的注释使用 jsdoc-tookit 转换为 JSON 格式的数据。
@name <string>
@author <string>
@type <string>
__@private__
  @param [<Object>{type: <string>, name: <string>, description: <string>, isOptional: <boolean>}]
  @returns [<Object>{type: <string>, description: <string>}]
@description <string>
@example [<string>]
  @requires [<string>]
@since <string>
@deprecated <string>
@see [<string>]
------------------------------------
以上 constructor 和 function 的 isFunction 为 true，其他的 property 没有以下四个属性：
@param @exceptions @returns @requires

>2012-03-15
编写 api 文档。

>2012-03-12
取消 runApplication 的一次调用的限制，以利扩展旧代码。

>2012-03-11
修改 Dialog 的设计，省略三个参数，将 maskTarget 和 pinnedTarget 合并为对话框元素的父元素，这样处理便于理解和使用。
以前的注释如下：
/**
 * 对话框。
 * @param {Element} element 要作为对话框显示的元素。
 *   该元素的 position 将在创建后视情况而被修改为 absolute 或 fixed，另外建议为该元素设置像素单位的 left、top 和明确的 zIndex。
 * @param {Object=} options 可选参数，这些参数的默认值保存在 Dialog.options 中。
 * @option {?Element|Object} maskTarget 要遮盖的元素，该元素必须创建了 stacking context。可以为 null，但如果指定，则应为 element 的同级或祖先级元素。
 *   当其值为 window 时，将遮盖整个视口。
 *   当多个对话框指定了同一个 maskTarget 时，则视这些对话框为一组，将对话框分组有利于重叠显示这些对话框。
 * @option {Object} maskAttributes 为遮盖层元素附加的属性，仅在 maskTarget 不为 null 时有效。
 * @option {Object} maskStyles 为遮盖层元素设置的样式，仅在 maskTarget 不为 null 时有效。
 * @option {?Element|Object} pinnedTarget 定位的目标元素，将对话框的中心点固定在该元素的中心点，可以为 null，但如果指定，则应为 element 的同级或祖先级元素。
 *   当其值为 window 时，对话框的中心点将保持与视口的中心点重合。
 * @option {number} pinnedOffsetX 对话框的左边与 pinnedTarget 的左边的横向差值，仅在 pinnedTarget 不为 null 时有效。
 *   如果指定，对话框的中心点在横向将不再与 pinnedTarget 的中心点重合。
 * @option {number} pinnedOffsetY 对话框的顶边与 pinnedTarget 的顶边的纵向差值，仅在 pinnedTarget 不为 null 时有效。
 *   如果指定，对话框的中心点在纵向将不再与 pinnedTarget 的中心点重合。
 * @option {Function} onOpen 调用 open 方法时触发。
 * @option {Function} onClose 调用 close 方法时触发。
 *
 * 注意：
 *   为避免复杂嵌套导致的对话框定位有误的问题，建议将对话框元素作为 body 的子元素。
 *   对话框的默认状态为关闭。因此 element 的 display 将被设置为 none。
 *   若对话框的 position 为 fixed，则当对话框无法完整显示在视口内的时候，忽略上述 pinnedTarget 和 pinnedOffsetX/pinnedOffsetY 的设置，自动调整对话框的位置，使其保持可见。
 *   maskTarget 和 pinnedTarget 指定为 window 时，内部实现是转化为 document.body 处理的。
 *   // TODO: window/document/document.documentElement/document.body 全部接受？
 */

>2012-03-10
freezeFocusArea
修改 Mask，参考以前的 setMaskBehind，实际上 Mask 是为了衬托另一个元素，因此应与上一个元素紧密相关。
Dialog

>2012-03-09
plugins.console 升级，界面更实用，并支持历史纪录保存。

>2012-03-08
position:fixed 植入 setStyle
同时对相关特性 position/display/left/right/top/bottom 进行修复。

>2012-03-07
修复 IE6 的 position:fixed。

>2012-03-05
components.switcher
完善 components.mask，支持任意元素覆盖，并修正 IE8 Opera 的 bug。

>2012-03-04
- 调用 runApplication 之后，这两个方法都将不能再次调用。加入此限制是为了确保可读性（declareModule 在 runApplication 之前，并且 runApplication 只被调用一次）。
可以在一个应用运行之后建立新模块，或者新应用，以增加可扩展性。

>2012-03-01
document.preloadImages
为便于脚本编写，修改以下部分：
getStyle/getStyles/setStyle/setStyles 的 css property name 参数改为允许 camel case。
setStyle/setStyles 的长度单位允许省略像素单位 'px'。

>2012-02-28
storage

>2012-02-26
modularization

>2012-02-24
Element.prototype 提前，后添加各方法。

>2012-02-23
修复 fadeIn/fadeOut 的 bug。
request animation dom 代码微调，加注释。

>2012-02-21
修复 Request 同步回调的问题，限制 minTime 和 maxTime 仅在异步模式下生效。

>2012-02-17
-Element.prototype.wait
Element.prototype.fadeIn
Element.prototype.fadeOut

>2012-02-16
Element.prototype.animate + 队列（参数暂不公开）
Element.prototype.stopAnimate
Element.prototype.wait

>2012-02-15
Animation & +engine
Element.prototype.animate

>2012-02-14
String.prototype.clean

>2012-02-13
调整注释结构
正则提出为常量 (还差 dom)
辅助函数改为函数表达式
  - WebStorm 格式化代码时会自动在函数声明上下插入空行，另外函数声明的函数名称会被特殊高亮，这两点有时会影响代码阅读。

>2012-02-12
整理代码，调整注释结构。
-browser.js
+base.js

>2012-02-11
Object.forEach
String.prototype.repeat
String.prototype.startsWitht
String.prototype.endsWitht
String.prototype.containst
String.prototype.toArrayt
Number.prototype.isFinite
Number.prototype.isNaN
Number.prototype.isInteger
Number.prototype.toInteger
扩充 typeOf，解决旧 IE 的 function 为 object.Object 的问题。

>2012-02-10
XHR -> Request

>2012-02-09
XHR

>2012-02-08
ua -> browser
Number.prototype.toRegular

>2012-02-07
domReady 整理
window.onbeforeunload 处理
getComputedStyle -> getStyles
setInlineStyle -> setStyles
Math.limit

>2012-02-06
remove
replace
empty

>2012-01-30
事件模型使用 2012-01-24 版本，2012-01-29 版的删除事件时麻烦……
drag 事件原本可以实现没有拖拽位移时仍可以弹出右键菜单的功能，但 Safari 在 mousedown 时即出现右键菜单，因此调整功能，改为仅支持左键拖拽，简单。

>2012-01-29
事件模型继续进行中，缩减一层更利于 debug。

>2012-01-28
drag 一组事件完成，实现冒泡、排除异常操作干扰等特性。

>2012-01-24
事件模型新规划：
/*
pool - item(uid) - manager(type): {
                                     handlers: [
                                       {
                                         name: <string>
                                         listener: <Function>
                                         filter: <Function>
                                       }
                                     ].delegateCount: <number>,
                                     dispatcher: <Function>.domEventType<string>
                                                           .useCapture<string>
                                   }
*/

Lv1:
内置 - Direct & 自定义事件
  1 个，监听的事件发生时触发。

Lv2:
内置 - 需 Fix
  1 个或 2 个，替代的事件（组合）发生时触发。
  dispatcher: domEventListener<Function>.domEventType<string>
                                        .useCapture<string>

Lv3:
复合事件（目前仅有 dragstart drag dragend）
  三类共用 1 个，这个事件发生时再额外注册 3 个。
  dispatcher: domEventListener<Function>.domEventType<string>
                                        .useCapture<string>

不能使用 Lv1 的事件模拟 Lv2+ 的事件，避免出现 jQuery 中类似以下代码的问题（移除一个事件影响到另一个事件的正常处理）：
/*
jQuery('#i2').on('change', function(e) {
  console.log('::change::', e.target.value);
});
jQuery('#i2').off('click');
*/
因此每个 category 必然有至少一个 dispatcher。
另外 jQuery 向派发器中仅传递目标元素，因此每个元素只使用一个公用的 dispatcher，并为此建立了原生事件类型-自定事件类型的哈希表。
（垂直+变种结构）
本方案要向派发器中传递目标元素及事件类型，因此都使用各自的 dispatcher。
（平铺结构）

>2012-01-21
整理事件处理部分。
fire

>2012-01-16
加入 putBefore/putAfter，append，prepend，remove，replace 方法。

>2012-01-15
将 traversal 方法拆分和扩展为 getParent getPrevious getNext getFirstChild getLastChild getChildren 六个方法。
getChildElementCount -> getChildrenCount
为了向后兼容和简化功能，本框架处理 Node 时仅关注 Element，因此上述 API 均未直接体现具体 Node 类型，因为涉及的类型全部为 Element。

__uid__ -> uid; 1201 -> 1;

取消跨 Frame 的支持，去掉 document 参数，参见 2011-11-14。

$xxx 只被用来命名于已被扩展的 Element 对象，框架内代码也是如此。

>2012-01-12
更新 typeOf 函数，并调整影响到的代码。

>2011-12-05
json2.js

>2011-12-01
为 setStyle 加入 number 类型误传的处理。

>2011-11-30
getData
setData
removeData

>2011-11-28
加入事件代理支持。
contains -> isAncestorOf

>2011-11-25
拟更改事件模型，以支持事件代理。
/*
pool = {
  item(元素的 __uid__ 属性值): {
    type(事件类型): {
      'dispatcher': (普通事件调度器 = 仅在 type in generalEvents 时存在的 DOM 事件监听器),
      'listeners': [
        listener(事件监听器 - 并非直接监听 DOM 对象),
        ...
      ],
      'filters': [
        filter(事件代理过滤器)
        ...
      ]
    }(handler)
    ...
  }
  ...
};
*/
1. runEventListeners 中加入判断事件是否成立的函数（for 特殊事件）。
2. 重构 pool，传入 runEventListeners {dataset} 对象，在其中进行处理，先处理 delegates，逐级向上。

>2011-11-23
eventBus
Fix: relatedTarget 的 bug。

>2011-11-22
DD_belatedPNG

>2011-11-18
domready

>2011-11-17
addListener
removeListener
/*
pool = {
  item(元素的 __uid__ 属性值): {
    type(事件类型): [
      listener(事件监听器 - 并非直接监听 DOM 对象),
    ].handler(普通事件处理器 = 仅在 type in generalEvents 时存在的 DOM 事件监听器),
    ...
  }
  ...
};
*/

>2011-11-16
移除 viewport。
Event 相关资料收集。

>2011-11-15
由于不打算提供跨 frame 操作，因此可以取消 viewport 的设定，将获取视口尺寸、滚动的三个方法直接绑在 window 上。
原本计划在 viewport 上提供的 scrollTo/By resizeTo/By 方法，其实只有一个 resizeTo 在弹出窗口时可能会用到，但弹出窗口目前几乎不
会使用。
去掉 viewport 后，就在基础库里减少了这个唯一新增的对象。

>2011-11-14
comparePosition
Event(part)
$ 方法仍只支持传入 Element 或 null，因此需要扩充 typeOf。
考虑：是否支持跨 Frame？
  现在的版本支持该功能，但有个问题：frame 中的 window/document 默认没有 addListener 属性，如果支持，为保持 API 的一致性，要么
  页面内的 window/document 不做预处理（这样的话用起来会显得很奇怪），要么在 frame 页面载入后马上为其扩充（这个代价太大）。
  mootools 是通过 IFrame 构造函数来达到目的的，为此引入一个新类型，也是无奈之举。难免会让人想为什么没有 select/table 类？它们
  甚至有 DOM 专门为其提供的 API……
  实际上跨 frame 操作并不常见，通常也不建议这样做。必须跨 frame 时，应将 frame 作为一个模块，在其内也引入 js 库，两侧通过
  事件通信，这样的代码更易于理解与划分模块。
结论：抛弃此功能，该功能将在“事件”部分完成后去除（即去除所有相关的“document”参数），这样可以确保 API 的一致性（仅供在当前页面
操作），并且更简单。

>2011-11-11
viewport.getxxx

>2011-11-08
HTMLElement.prototype.innerText
HTMLElement.prototype.outerText
HTMLElement.prototype.outerHTML
console 完善，解决作用域的问题。（昨天没有将创建的节点插入文档树，导致脚本执行后的结果丢失。）

>2011-11-07
console
Object.update

>2011-11-06
ElementWrapper 方式改为直接绑定 + 扩展 Element.prototype 方式。
Object.append
getChildElementCount
traversal

>2011-11-05
DOM 的静态方法模式改为 ElementWrapper 方式。
封装并扩展 Element，将 attributes 和 properties 区别对待。
对于 attributes，拟建立一个映射表，仅允许合法的 set/get attribute，不建议的给出警告（调试信息）。其中特殊处理的如下：
  class -> has/add/remove/toggleClass
  style -> getComputedStyle setStyle
对于 properties，将常用的部分封装为方法：
  Element Traversal
  CSS Object Model View
  增/删/移动 DOM 节点的方法

>2011-11-04
find (Sizzle)

>2011-11-03
ES5 Shims

>2011-11-02
typeOf
Array.from
getComputedStyle

>2011-11-01
getElement
createElement
$
