<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>OurJS 简介</title>
<script src="../our.js"></script>
<script src="../scripts/framework.js"></script>
<script src="../scripts/prettify.js"></script>
<link rel="stylesheet" href="../stylesheets/prettify.css">
<style>
ul ul { color: #666; font-size: 12px; }
ul ul p { margin-bottom: 0; }
ul ul pre { margin-top: 5px; border-color: silver; background-color: #F8F8F8; }
</style>
<script>
execute(function($) {
  // 代码高亮。
  $(document.body).find('pre').forEach(function($pre) {
    $pre.addClass('prettyprint');
  });
  prettyPrint();
}, true);
</script>
</head>
<body>
<div id="content">
  <h1>OurJS 简介</h1>
  <p>OurJS 是一个适用于 WEB 开发的 JavaScript 框架。</p>
  <p>它能让开发者使用可预期的 API 自由的编程，写出具备良好的兼容性<sup>1</sup>、可读性和扩展性的代码。</p>
  <p>它的主旨是化繁为简。<sup>2</sup></p>
  <ol class="comment">
    <li>
      目前完全兼容 PC 端的 IE6+、Firefox、Chrome、Safari、Opera 以及其他使用 Trident 和 WebKit 内核的浏览器。<br>
      稍后还会对移动设备提供支持。
    </li>
    <li>
      一方面，开发者可以通过愉快的开发过程得到预期的结果，并且不用担心项目改动带来过多的工作量，从而觉得工作是简单的。<br>
      另一方面，OurJS 不会把简单问题复杂化，不引入除 JS 和 DOM 范畴外的新概念，避免使用容易被误会的包装对象——如果你抬起头来就可以看见月亮，又何必去爬树？
    </li>
  </ol>
  <blockquote>
    <p>
      "Everything should be made as simple as possible, but no simpler." -- Albert Einstein<br>
      “任何事情都应该尽可能的做到简单，简单到极致。”—— 爱因斯坦
    </p>
  </blockquote>

  <h2>开发者和框架</h2>
  <p>现在，JavaScript 的使用人群已经非常广，它入门简单，使用灵活，在 WEB 开发中有着无可替代的位置，甚至在整个互联网中也是一个不可或缺的元素。</p>
  <p>虽然 JavaScript 本身还有一些缺陷、让代码能够兼容各种浏览器也很头疼，但对于 WEB 应用的开发者来说，这些问题都可以通过使用各种层出不穷的框架或类库<sup>1</sup>来解决。</p>
  <p>当开发者准备着手一个项目时，通常会有以下三个关注点，并根据实际情况选择某种手段<sup>2</sup>进行开发：</p>
  <ul>
    <li>
      <p class="referral">“<strong>过程</strong>”——是否愉快？</p>
      <p class="comment">
        在整个开发过程中，希望可以保持轻松愉快、甚至充满乐趣。<br>
        如果某种手段让自己感觉被束缚住，或者经常感到意外，那么这就不是个好手段。
      </p>
    </li>
    <li>
      <p class="referral">“<strong>结果</strong>”——能否达成？</p>
      <p class="comment">
        无论使用何种手段，都应该可以达到预期的目标。<br>
        如果某种手段导致最终实现与预期的目标不符，那么就不会使用这个手段。
      </p>
    </li>
    <li>
      <p class="referral">“<strong>维护</strong>”——是否容易？</p>
      <p class="comment">
        希望代码有良好的可读性，功能有良好的可扩展性。<br>
        如果某种手段产生了耦合度很高的代码，或有不易于扩展的结构，那么是无法接受的。
      </p>
    </li>
  </ul>
  <p>
    当前流行的框架或类库有很多，每个开发者都有自己的观点，都会在根据情况作出选择。<br>
    在这些框架或类库中，没有“最好”的，只有“最合适”的。如果说以上三个关注点都有其各自的坐标轴，那么每个框架或类库都有其自己的定位和问题：
  </p>
  <ul>
    <li>
      <p class="referral">要突出“<strong>过程</strong>”使人愉快的，难免过于灵活，写代码的时候天马行空，最终却带来了令人头疼的“<strong>维护</strong>”问题。</p>
      <p class="comment">什么？又要加功能？呃……看来这部分代码要重构了……</p>
    </li>
    <li>
      <p class="referral">“<strong>结果</strong>”是所有框架或类库都会努力追求的，但从功能的细节上来讲，仍各有千秋。</p>
      <p class="comment">细节很重要。一些框架或类库提供的功能或组件的细节不够完善，可能导致最终实现与期望的结果略有偏差。</p>
    </li>
    <li>
      <p class="referral">而要强调“<strong>维护</strong>”容易的，难免设计的过于严谨，有很多的规则限制，从而使“<strong>过程</strong>”变得有些痛苦。</p>
      <p class="comment">好长的命名空间……类？嗯……implement……extend……这里我要怎么写才对？噢！类型传错了……我必须加一段注释了……</p>
    </li>
  </ul>
  <p>
    看到这里时，你可能已经想到了某些框架或类库了。那么你是否也认为上述问题是确实存在的？<br>
    或者你什么也没想到，只是偶尔写一些 JS 代码，正在寻找一个容易上手的框架简化开发，并且希望在将来技术水平提高之后，依然可以继续使用它？
  </p>
  <p>请看下一节。</p>
  <ol class="comment">
    <li>本文中的“框架或类库”特指面向 WEB 开发的框架或类库，并不包括为了解决某个单一问题而设计的类库或组件。</li>
    <li>此处是指使用已有的框架或类库来简化开发。</li>
  </ol>

  <h2>OurJS 的定位</h2>
  <p>按照上一节提到的三个关注点，OurJS 的定位</p>


  <h2>OurJS 的特点</h2>
  <h3>语法自然 —— 所有 API 的语法均符合原生 JS 和 DOM 的语法习惯。</h3>
  <ul>
    <li>
      <p>
        对于一些在新的规范（草案）中定义的，或已成为事实标准的特性，在尚未支持的浏览器上通过技术手段予以<strong>补缺</strong>。<br>
        这些 API 的语法是原生的，也是最自然的。使用它们时，开发者可以像面对最新的浏览器一样编写代码。
      </p>
      <ul>
        <li>
          <p>数组的 forEach 方法是 ECMAScript 5 引入的，本来只有在较新版本的浏览器中才能使用，但现在可以放心使用了：</p>
          <pre>anArray.<strong>forEach</strong>(function(item) {...});</pre>
        </li>
        <li>
          <p>HTML5 的 localStorage 对象和 ECMAScript 5 的 JSON 对象原本在 IE6 IE7 中是不支持的，但现在可以放心使用了：</p>
          <pre><strong>localStorage</strong>.setItem('data', <strong>JSON</strong>.stringify(userData));</pre>
        </li>
        <li>
          <p>IE6 IE7 本来没有 Element 构造函数，但现在可以通过扩充 Element.prototype 来为页面上的 DOM 元素添加新特性了：</p>
          <pre>Element.<strong>prototype</strong>.newMethod = function() {...};</pre>
        </li>
      </ul>
    </li>
    <li>
      <p>
        对于有规范支持但无法通过技术手段实现补缺的，或者无规范支持仅为方便使用而提供的特性，以<strong>扩展</strong>的方式提供。<br>
        设计这些扩展的 API 时均参考了原生 API 的语法，语义明确，并具备“自注释”的特点。
      </p>
      <ul>
        <li>
          <p>IE6 并不支持 CSS2 引入的固定定位，但现在通过使用 element.setStyle/setStyles 方法，可以在 IE6 中实现固定定位：</p>
<pre>
element.<strong>setStyles</strong>({position: 'fixed', right: 0, bottom: 0});
// 此时使用 element.getStyle/getStyles 获取 position 的值在 IE6 中也可以正确的获得 'fixed'。
</pre>
        </li>
        <li>
          <p>IE6 IE7 IE8 的事件模型与其他浏览器不同，但现在可以通过 element.on/off/fire 方法来统一实现事件处理函数的绑定/解除绑定/触发了：</p>
<pre>
element.<strong>on</strong>('click', function(e) {...});
// 事件对象 e 也做了兼容性处理，确保在所有浏览器中有一致的表现。
</pre>
        </li>
        <li>
          <p>OurJS 还提供了一些虽然目前尚无规范支持，但却很实用的方法，如将一个 NodeList 对象（或其他任意数据类型）转化为数组：</p>
          <pre>Array.<strong>from</strong>(element.getElementsByTagName('select')).forEach(function(item){...});</pre>
        </li>
      </ul>
    </li>
  </ul>

  <h3>风格一致 —— 功能上有共同点的 API 也有共同的风格，便于记忆，并可以通过熟悉的 API 推测出其他 API 的用法。</h3>
  <ul>
    <li>
      <p>不同对象的同类方法的名称一致，同名参数的含义也基本一致。</p>
      <ul>
        <li>
          <p>
            Array 和 Object 的 forEach 方法的作用均为遍历。<br>
            它们的 callback、thisObj 参数的作用以及 callback 函数将被传入的参数也完全相同。<br>
            不同的是 Array 的 forEach 方法是实例方法，而 Object 的 forEach 则为静态方法。
          </p>
        </li>
        <li>
          <p>
            cookie 和 localStorage 这两个和存储有关的对象都有 getItem、setItem 和 removeItem 方法来进行获取、修改和删除的操作。<br>
            并且它们的参数 key 和 value 都代表数据名和数据值，都是字符串类型。
          </p>
        </li>
        <li>
          <p>
            DOM 对象和组件对象处理事件的方法都是 on、off 和 fire。<br>
            它们的 name 参数格式略有不同，因为组件的事件不像 DOM 事件那样可以传递，因此没有“代理”的概念。<br>
            它们的 listener 参数的含义和作用则完全一致，并且当 listener 被调用时，this 的值也均为监听的目标对象。
          </p>
        </li>
      </ul>
    </li>
    <li>
      <p>所有组件均具备选项设置和事件处理的功能。</p>
      <ul>
        <li>
          <p>
            所有组件的构造器均有一个 options 属性，表示该组件的默认选项（没有选项的组件除外）。<br>
            修改 options 属性可以修改此类组件的默认选项。使用这种方式设置的选项对后续创建的组件均生效。
          </p>
          <pre>Request.<strong>options</strong>.method = 'post';</pre>
        </li>
        <li>
          <p>
            所有组件的构造器均有一个 options 参数，表示该创建组件实例时的选项（没有选项的组件除外）。<br>
            通过参数 options 能够指定本次创建的实例的选项。使用这种方式设置的选项仅对本次创建的实例生效。
          </p>
          <pre>var request = new Request('/product/getfriends', <strong>{method: 'get'}</strong>);</pre>
        </li>
        <li>
          <p>
            所有组件的实例均有 setOptions 方法，可以用来修改该实例的选项（没有选项的组件除外）。<br>
            使用这种方式设置的选项将在该实例上直接生效。
          </p>
          <pre>request.<strong>setOptions({headers: {uid: 12345}})</strong>;</pre>
        </li>
        <li>
          <p>所有组件都可以通过 on、off 和 fire 方法来处理事件。</p>
        </li>
        <li>
          <p>执行每个组件的实例方法时，都会触发一个同名事件。</p>
        </li>
      </ul>
    </li>
  </ul>

  <h3>功能完善 —— 提供覆盖面广、粒度恰当的功能，可以通过灵活的配置和组合来实现 WEB 开发中的绝大多数需求。</h3>
  <ul>
    <li>
      <p>OurJS 通过<strong>扩展</strong> JS 内置对象、浏览器内置对象、DOM 对象，<strong>封装</strong>组件，<strong>模块化管理</strong>代码等方式，提供了丰富的功能。</p>
    </li>
    <li>
      <p>每个功能都经过长期实践，其行为和细节更完善，其设计粒度更符合常见的应用场景。</p>
      <ul>
        <li>
          <p>
            当某个需求可以通过灵活使用某个已有功能，或可以清晰的通过组合多个功能实现时，则不会提供另一个新的功能，以保持 API 的简洁。<br>
            比如要把元素 A 插入到元素 B 的前边，使用 A.putAfater(B) 即可实现，因此没有提供 B.someMethod(A) 这样的方法。
          </p>
        </li>
        <li>
          <p>
            Request 组件设计为每发送一个请求就必然会收到一个响应，即便本次请求超时、或本次请求被取消的情况下也是如此。其内置的被动事件只有 start 和 finish 两个。<br>
            在请求结束时可以在 finish 事件监听器中统一处理一些状态的设定或恢复，如将 start 事件监听器中显示的提示信息隐藏。<br>
            在实际应用中，响应状态码是 200 的情况未必代表“操作成功”，或者说一个操作未必只有“成功”和“失败”、“超时”这三种状态，因此大多数库中预置的这些类型的事件或回调是不合适的，反而束缚了开发者。<br>
            而使用 OurJS 提供的 Request 组件对一次请求结果的详细判断可以通过 finish 事件的监听器中传入的事件对象进行处理，或者使用 responseParser 进行预处理，必要时开发者还可以根据情况添加自定义事件 success、failure、timeout 等。<br>
            如果在本项目中与服务端的数据交互格式有明确的约定，那么可以将上述处理设置到 Request 组件的默认选项内，以实现本项目定制版的异步交互组件。
          </p>
        </li>
        <li>
          <p>
            Animation 组件可以通过添加多个动画剪辑来实现复杂的动画效果和动画队列。该组件支持多种事件并提供了多种控制手段，用户可以随时暂停、停止或反向播放动画。<br>
            Animation 的动画引擎使用了“同频同步”的方式来同时播放多个动画，这种方式可以降低浏览器的资源消耗，使动画播放的更流畅。<br>
            Animation 还封装了常见的针对某一个元素的补间动画，并以 Element.prototype.morph/highlight/fadeIn/fadeOut 等形式提供了快捷的 API。
          </p>
        </li>
      </ul>
    </li>
  </ul>

  <h3>易于扩展 —— 不论是要扩展框架本身，还是扩展应用，OurJS 均提供了简易的方式。</h3>
  <ul>
    <li>
      <p class="referral">要为基础类型的对象扩展功能，扩展其构造器的 prototype 即可（但应避免扩展 Object 的原型）。</p>
      <p class="comment">OurJS 并没有提供特别的方法来做这件事情，用这种 JS 固有的方式来做这件事，可以让代码的目的更加的明确。</p>
    </li>
    <li>
      <p class="referral">OurJS 有组件构造器，要添加新的组件，使用组件构造器即可创建出和现有组件具有相同特性的新组件。</p>
      <p class="comment">
        要扩展已有的组件，使用 Component 提供的事件机制来添加新的事件（可以为组件添加任意多的自定义事件类型），并在对应的监听器中进行必要的处理即可。<br>
        OurJS 没有提供“继承”的机制，这是为了避免引入不必要且不严密的概念而将简单问题复杂化。当一个组件依赖另一个时，使用“组合”的方式会更加灵活可控（具体的实施方式可以参考 TabPanel 和 Slideshow 的源码）。
      </p>
    </li>
    <li>
      <p class="referral">面对复杂的需求，OurJS 提供了“模块-应用”机制来化繁为简。使用这个机制来编写的应用，在需要扩展其功能时，为其添加新的模块，并添加新的应用函数来处理新的逻辑即可。</p>
      <p class="comment">这样做可以避免新增的逻辑影响以前的代码，并且只对新模块进行单独的测试即可。<br>灵活使用模块-应用机制，可以游刃有余的应对频繁改动的项目。</p>
    </li>
  </ul>

  <h2>OurJS 的要求和限制</h2>
  <h3>OurJS 会强制浏览器运行在“标准模式”下。</h3>
  <p>这样可以确保开发者编写出规范的代码，并获得更好的兼容性、发挥浏览器的最大功效。</p>
  <p>当浏览器工作在非标准模式下时，开发者将收到一条警告信息。</p>

  <h3>OurJS 只可以和非侵入式设计的类库共存。</h3>
  <p>OurJS 具备完善的功能，也提供了基于组件形式的扩展，因此能够独立解决大部分需求。</p>
  <p>当必须引入其他的类库以满足特定需求时，要注意：OurJS 使用了侵入式设计<sup>1</sup>，因此不能和其他使用同样方式设计的类库共存<sup>2</sup>。</p>
  <ol class="comment">
    <li>
      JavaScript 框架提供 API 的风格有三种：静态方法、包装对象和原型扩展。<br>
      为了提供<strong>自然的语法</strong>，并保持 <strong>API 的一致性</strong>，OurJS 优先使用了“原型扩展”这种方式。<br>
      一些无法使用“原型扩展”的功能使用“静态方法”提供，如 Object.append，Date.from 等。<br>
      只有事件对象使用了“包装对象”方式，这是因为在处理浏览器兼容性问题时必须修改某些属性，而它们中的一部分在原生 DOM 事件对象中是只读的。
    </li>
    <li>可以和 jQuery 共存，并且彼此互不影响。</li>
  </ol>

</div>
</body>
</html>
